{"metaData": {"version": "1.0.0", "versionNumber": 65536}, "projectSettings": {"containers": {"dashboardSettings": {"parameters": [{"value": "", "controlAddress": "/showDashboardOnStartup", "enabled": false}]}, "customDefinitions": {}, "rmpSettings": {}}}, "dashboardManager": {"viewOffset": [0, 0], "viewZoom": 1.0}, "parrots": {"viewOffset": [0, 0], "viewZoom": 1.0}, "layout": {"mainLayout": {"type": 1, "width": 1920, "height": 997, "direction": 2, "shifters": [{"type": 1, "width": 1920, "height": 997, "direction": 1, "shifters": [{"type": 1, "width": 1554, "height": 997, "direction": 1, "shifters": [{"type": 1, "width": 343, "height": 997, "direction": 2, "shifters": [{"type": 0, "width": 343, "height": 288, "currentContent": "Screens", "tabs": [{"name": "Screens"}]}, {"type": 0, "width": 343, "height": 703, "currentContent": "Medias", "tabs": [{"name": "Medias"}]}]}, {"type": 1, "width": 1204, "height": 997, "direction": 2, "shifters": [{"type": 0, "width": 1204, "height": 701, "currentContent": "Screen Editor", "tabs": [{"name": "Screen Editor"}]}, {"type": 0, "width": 1204, "height": 290, "currentContent": "Sequence Editor", "tabs": [{"name": "Sequence Editor"}, {"name": "Online Explorer"}]}]}]}, {"type": 1, "width": 360, "height": 997, "direction": 2, "shifters": [{"type": 0, "width": 360, "height": 717, "currentContent": "Inspector", "tabs": [{"name": "Inspector"}]}, {"type": 0, "width": 360, "height": 274, "currentContent": "Logger", "tabs": [{"name": "Logger"}]}]}]}]}, "windows": null}, "media": {"items": [{"parameters": [{"value": "Image/Golden Gang Ultreia_1920x1080.png", "controlAddress": "/filePath"}], "niceName": "Mire FullHD", "containers": {"mediaParameters": {}}, "type": "Picture"}, {"parameters": [{"value": "Image/Golden Gang Ultreia_1024x768.png", "controlAddress": "/filePath"}], "niceName": "Mire XGA", "containers": {"mediaParameters": {}}, "type": "Picture"}, {"parameters": [{"value": "Image/Golden Gang Ultreia_1080x1920.png", "controlAddress": "/filePath"}], "niceName": "Mire Full HD Portrait", "containers": {"mediaParameters": {}}, "type": "Picture"}, {"parameters": [{"value": 1350, "hexMode": false, "controlAddress": "/width"}, {"value": 954, "hexMode": false, "controlAddress": "/height"}, {"value": "ShaderToy File", "controlAddress": "/shaderType"}, {"value": "C:/Users/ULTREIA/Desktop/grid.shader", "controlAddress": "/fragmentShader"}, {"value": "Mfs3D2", "controlAddress": "/shaderToyID"}, {"value": "Bd8jRr", "controlAddress": "/shaderToyKey"}, {"value": false, "controlAddress": "/keepOfflineCache"}, {"value": [1.0, 1.0, 1.0, 1.0], "controlAddress": "/backgroundColor"}], "niceName": "Test Pattern Fond de sc\u00e8ne", "containers": {"mediaParameters": {}, "sourceMedias": {}}, "type": "Shader", "shaderCache": "// \u00cd\u00f1igo Qu\u00edlez\r\n// https://iquilezles.org/articles/distfunctions2d/\r\n#define     TAU 6.28318530717958647 // pi * 2\r\n#define     PI  3.14159265358979323 // pi\r\n\r\n// hsv to rgb\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\r\n  rgb = rgb * rgb * (3. - 2. * rgb);\r\n  return c.z * mix(vec3(1.), rgb, c.y);\r\n}\r\n\r\n// sd polygon\r\nconst int N = 8;\r\nfloat sdPolygon( in vec2 p, in vec2[N] v )\r\n{\r\n    int num = v.length();\r\n    float d = dot(p-v[0],p-v[0]);\r\n    float s = 1.0;\r\n    for( int i=0, j=num-1; i<num; j=i, i++ )\r\n    {\r\n        // distance\r\n        vec2 e = v[j] - v[i];\r\n        vec2 w =    p - v[i];\r\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\r\n        d = min( d, dot(b,b) );\r\n\r\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\r\n        bvec3 cond = bvec3( p.y>=v[i].y, \r\n                            p.y <v[j].y, \r\n                            e.x*w.y>e.y*w.x );\r\n        if( all(cond) || all(not(cond)) ) s=-s;  \r\n    }\r\n    \r\n    return s*sqrt(d);\r\n}\r\n\r\n// sd segment\r\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p-a, ba = b-a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    return length( pa - ba*h );\r\n}\r\n\r\n// sd box\r\nfloat sdBox( vec2 p, vec2 b, vec2 o)\r\n{\r\n    p -= o;\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\n// sd circle\r\nfloat sdCircle( vec2 p, float r )\r\n{\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\r\n\r\n// sd rhombus\r\nfloat sdRhombus( in vec2 p, in vec2 b ) \r\n{\r\n    p = abs(p);\r\n\r\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\r\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\r\n\r\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\r\n}\r\n\r\n// sd distorted pill\r\nfloat sdDistortedPill(vec2 p, vec2 start, vec2 end, float radius, float power, float depth)\r\n{\r\n    p = -p;\r\n    vec2 dir = normalize(end - start);\r\n\r\n    vec2 localP = p - start;\r\n    float proj = dot(localP, dir);\r\n    float perpProj = dot(localP, vec2(-dir.y, dir.x));\r\n\r\n    float alongLine = clamp(proj, 0.0, length(end - start));\r\n    vec2 closestPoint = start + dir * alongLine;\r\n\r\n    float d = length(p - closestPoint) - radius;\r\n\r\n    float frequency = PI / length(end - start);\r\n    float sind = sin(frequency * alongLine);\r\n    sind = pow(sind, power);\r\n    sind *= depth*radius;\r\n    \r\n    return d + sind;\r\n}\r\n\r\n\r\n// stroke edge\r\nvoid stroke(float d, vec4 c, inout vec4 fragColor, float w)\r\n{\r\n    float m = 1.0-step(.5*w, abs(d));\r\n    fragColor = mix(fragColor, c, m*c.a);\r\n}\r\n\r\n// stroke edge with anti-aliasing\r\nvoid strokeAA(float d, vec4 c, inout vec4 fragColor, float w, float aa)\r\n{\r\n    float m = smoothstep(0.5 * (w + aa), 0.5 * (w - aa), abs(d));\r\n    fragColor = mix(fragColor, c, m*c.a);\r\n}\r\n\r\n// background color\r\n#define bg_c vec4(0.0, 0.0, 0.0, 1.0)\r\n\r\n// grid color\r\n#define grid_c vec4(.5, .5, .5, 1.0)\r\n\r\n// grid line width\r\n#define grid_w 2.0\r\n\r\n// grid vertical divisions\r\n// grid cross\r\n#define grid_s vec2(9.0, 0.0)                     \r\n\r\n// circlegrid color\r\n#define circlegrid_c vec4(0.5)\r\n\r\n// circlegrid line width\r\n// circlegrid size\r\n// circlegrid offset x\r\n// circle grid offset y\r\n#define circlegrid_s vec4(1.0, .25, 0.0, 0.0)\r\n\r\n// circle color\r\n#define circle_c vec4(1.0)\r\n\r\n// circle line width\r\n#define circle_w 2.0\r\n\r\n// TL to BR diagonal color\r\n#define diag1_c vec4(.5, 1.0, .75, 1.0)\r\n\r\n// BL to TR diagonal color\r\n#define diag2_c vec4(1.0, .5, .666, 1.0)\r\n\r\n// diagonal line width\r\n#define diag_w 2.0\r\n\r\n// horizontal centerline color\r\n#define centerh_c vec4(1.0, 1.0, .5, 1.0)\r\n\r\n// vertical centerline color\r\n#define centerv_c vec4(1.0, 1.0, .5, 1.0)\r\n\r\n// center line width\r\n#define center_w 2.0\r\n\r\n// rainbow line width\r\n// rainbow alpha\r\n// rainbow period\r\n// rainbow offset\r\n#define rainbow_s vec4(3.0, 1.0, 2.0, .17)\r\n\r\n// border color\r\n#define border_c vec4(.5, 1.0, .5, 1.0)\r\n\r\n// border line width\r\n#define border_w 2.0\r\n\r\n// logo color 1\r\n#define logo_c1 vec4(0.0, 0.0, 0.0, 1.0)\r\n\r\n// logo color 2\r\n#define logo_c2 vec4(1.0, 1.0, 1.0, 1.0)\r\n\r\n// logo color 3\r\n#define logo_c3 vec4(.5, 0.5, 0.5, 1.0)\r\n\r\n// logo type\r\n// logo size\r\n#define logo_s vec2(0.0, .1)\r\n\r\n// grid\r\nvoid grid(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    float gc = (1.0 - grid_s.y)*.5;\r\n    vec2 grid = p - round(p*grid_s.x)/grid_s.x;\r\n    grid *= grid_s.x;\r\n    float d = min(abs(grid.x), abs(grid.y));\r\n    vec2 cross = vec2(step(gc, abs(grid.x)), step(gc, abs(grid.y)));\r\n    d += max(cross.x, cross.y);\r\n    stroke(d, grid_c, fragColor, grid_s.x*grid_w*px_size);\r\n}\r\n\r\n// circle grid\r\nvoid circleGrid(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    p -= circlegrid_s.zw/grid_s.x;\r\n    vec2 cell = mod(p * vec2(grid_s.x), 1.0);\r\n    vec2 center = mod(vec2(.5), 1.0);\r\n    float radius = circlegrid_s.y;\r\n    vec2 dist = cell - center;\r\n    float d = length(dist) - radius;\r\n    strokeAA(d, circlegrid_c, fragColor, circlegrid_s.x*grid_s.x * px_size, length(fwidth(p*grid_s.x)));\r\n}\r\n\r\n// circle\r\nvoid circle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\r\n{\r\n    center = center + round(p);\r\n    \r\n    float d = length(p - center) - radius;\r\n    strokeAA(d, c, fragColor, circle_w * px_size, length(fwidth(p)));\r\n}\r\n\r\n// rainbow circle\r\nvoid rainbowCircle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\r\n{\r\n\tvec2 pq = vec2(atan(p.x, p.y) / TAU*rainbow_s.z + rainbow_s.w, length(p));\r\n\tfloat d = length(p - center) - radius;\r\n\tc = vec4(hsv2rgb(vec3(pq.x, 1., 1.)), 1.0);\r\n\tstrokeAA(d, c, fragColor, rainbow_s.x * px_size, length(fwidth(p)));\r\n}\r\n\r\n// horizontal center line\r\nvoid centerH(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\r\n    p = mod(p, 1.0)-.5;\r\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\r\n}\r\n\r\n// vertical center line\r\nvoid centerV(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    stroke(abs(p.y), centerv_c, fragColor, center_w*px_size);\r\n    p = mod(p, 1.0)-.5;\r\n    stroke(abs(p.y), centerh_c, fragColor, center_w*px_size);\r\n}\r\n\r\n// diagonal lines\r\nvoid diagonals(vec2 p, float px_size, float aspect, inout vec4 fragColor)\r\n{\r\n\tp += .5;\r\n\tp = mod(p, 1.0);\r\n\t//p = p - floor(p);\r\n\r\n\tfloat dist = abs(p.x - p.y);\r\n\tstrokeAA(dist, diag1_c, fragColor, diag_w*px_size, length(fwidth(p)));\r\n\t\r\n\tdist = abs(p.x + p.y)-1.0;\r\n\tstrokeAA(dist, diag2_c, fragColor, diag_w*px_size, length(fwidth(p)));\r\n\t//fragColor = vec4(vec3(dist), 1.0);\r\n}\r\n\r\n// render border\r\nvoid border(vec2 p, vec2 res, inout vec4 fragColor)\r\n{\r\n\tfloat d = min(min(p.x, 1.0-p.x)*res.x, min(p.y, 1.0-p.y)*res.y);\r\n\tfragColor = mix(fragColor, border_c, 1.0-step(border_w, d));\r\n}\r\n\r\n\r\n// mw logo\r\nvoid mwLogo(vec2 p, vec2 offset, float scale, float aspect, float px_size, inout vec4 fragColor)\r\n{\r\n\tp -= offset;\r\n\tp.y *= .6;\r\n\tp /= scale;\r\n\t\r\n\t\r\n\tfloat w = 20.0 * px_size;\r\n\t\r\n\tvec2 ra =vec2(0.5,0.5);\r\n\tfloat d1 = sdRhombus( vec2(p.x + .5, p.y), ra );\r\n\tfloat d2 = sdRhombus( vec2(p.x - .5, p.y), ra );\r\n\tfragColor = mix(fragColor, vec4(vec3(pow(min(d1+.95, d2+.95), 8.0)), 1.0)*logo_c3, (1.0-step(0.0, min(d1, d2)))*logo_c3.a);\r\n\tstrokeAA(min(d1, d2), logo_c2, fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.1, d2+.1), logo_c2 * vec4(0.8), fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.2, d2+.2), logo_c2 * vec4(0.6), fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.3, d2+.3), logo_c2 * vec4(0.4), fragColor, w, length(fwidth(p)));\r\n\t\r\n\tfloat d3 = sdSegment(p, vec2(1.0, 0.0), vec2(-1.0, 0.0));\r\n\tstrokeAA(d3, logo_c2, fragColor, w, length(fwidth(p)));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized pixel coordinates\r\n    vec2 vUV = fragCoord/iResolution.xy;\r\n    \r\n    \r\n    // resolution\r\n    vec2 res = iResolution.xy;\r\n    \r\n    // aspect ratio\r\n    float aspect = res.x / res.y;\r\n\t\r\n\t// -.5 to .5 coordinate space\r\n\tvec2 p = vUV.st-.5;\r\n\t\r\n\tvec2 logo_offset = vec2(0.0, 0.0);\r\n\t\r\n\t// pixel size\r\n\tfloat px_size = 0.0;\r\n\t\r\n\t// alignment for different aspect ratios\r\n\tif (aspect > 1.0)\r\n\t{\r\n\t\tp.x *= aspect;\r\n\t\tlogo_offset.x = (aspect>1.0+logo_s.y*2.0)?.5 : .25;\r\n\t\tpx_size = 1.0/res.y;\r\n\t} else {\r\n\t\tp.y /= aspect;\r\n\t\tlogo_offset.y = (aspect<1.0-logo_s.y*2.0)?.5 : .25;\r\n\t\tpx_size = 1.0/res.x;\r\n\t} \r\n\t\r\n\r\n\t\r\n\t// background color\r\n\tfragColor = bg_c;\r\n\t\r\n\t// square grid\r\n\tgrid(p, px_size, fragColor);\r\n\t\r\n\t// circle grid\r\n\tcircleGrid(p, px_size, fragColor);\r\n\t\r\n\t// big circles\r\n    circle(p, vec2(0), 0.5, circle_c, px_size, fragColor);\r\n    \r\n    // diagonal lines\r\n    diagonals(p, px_size, aspect, fragColor);\r\n    \r\n    // vertical center lines\r\n\tcenterV(p, px_size, fragColor);\r\n\t\r\n\t// horizontal center lines\r\n\tcenterH(p, px_size, fragColor);\r\n\t\r\n\t// rainbow circle\r\n    rainbowCircle(p, vec2(0), .333, vec4(1.0), px_size, fragColor);\r\n\r\n\t// border lines\r\n    //vec2 b_pos = vec2(vUV.x * aspect, vUV.y);\r\n    //b_pos = vUV.xy * res;\r\n    border(vUV.st, res, fragColor);\r\n    \r\n\r\n    // mw logo\r\n\tmwLogo(p, logo_offset, logo_s.y, aspect, px_size, fragColor);\r\n\tmwLogo(p, -logo_offset, logo_s.y, aspect, px_size, fragColor);\r\n\r\n\t\r\n\t//pxGrid(p, px_size, fragColor);\r\n}", "sourceMedias": {}}, {"parameters": [{"value": 384, "hexMode": false, "controlAddress": "/width"}, {"value": 820, "hexMode": false, "controlAddress": "/height"}, {"value": "ShaderToy File", "controlAddress": "/shaderType"}, {"value": "C:/Users/ULTREIA/Desktop/grid.shader", "controlAddress": "/fragmentShader"}, {"value": "Mfs3D2", "controlAddress": "/shaderToyID"}, {"value": "Bd8jRr", "controlAddress": "/shaderToyKey"}, {"value": false, "controlAddress": "/keepOfflineCache"}, {"value": [1.0, 1.0, 1.0, 1.0], "controlAddress": "/backgroundColor"}], "niceName": "Test Pattern Fond de sc\u00e8ne jar", "containers": {"mediaParameters": {}, "sourceMedias": {}}, "type": "Shader", "shaderCache": "// \u00cd\u00f1igo Qu\u00edlez\r\n// https://iquilezles.org/articles/distfunctions2d/\r\n#define     TAU 6.28318530717958647 // pi * 2\r\n#define     PI  3.14159265358979323 // pi\r\n\r\n// hsv to rgb\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\r\n  rgb = rgb * rgb * (3. - 2. * rgb);\r\n  return c.z * mix(vec3(1.), rgb, c.y);\r\n}\r\n\r\n// sd polygon\r\nconst int N = 8;\r\nfloat sdPolygon( in vec2 p, in vec2[N] v )\r\n{\r\n    int num = v.length();\r\n    float d = dot(p-v[0],p-v[0]);\r\n    float s = 1.0;\r\n    for( int i=0, j=num-1; i<num; j=i, i++ )\r\n    {\r\n        // distance\r\n        vec2 e = v[j] - v[i];\r\n        vec2 w =    p - v[i];\r\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\r\n        d = min( d, dot(b,b) );\r\n\r\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\r\n        bvec3 cond = bvec3( p.y>=v[i].y, \r\n                            p.y <v[j].y, \r\n                            e.x*w.y>e.y*w.x );\r\n        if( all(cond) || all(not(cond)) ) s=-s;  \r\n    }\r\n    \r\n    return s*sqrt(d);\r\n}\r\n\r\n// sd segment\r\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p-a, ba = b-a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    return length( pa - ba*h );\r\n}\r\n\r\n// sd box\r\nfloat sdBox( vec2 p, vec2 b, vec2 o)\r\n{\r\n    p -= o;\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\n// sd circle\r\nfloat sdCircle( vec2 p, float r )\r\n{\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\r\n\r\n// sd rhombus\r\nfloat sdRhombus( in vec2 p, in vec2 b ) \r\n{\r\n    p = abs(p);\r\n\r\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\r\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\r\n\r\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\r\n}\r\n\r\n// sd distorted pill\r\nfloat sdDistortedPill(vec2 p, vec2 start, vec2 end, float radius, float power, float depth)\r\n{\r\n    p = -p;\r\n    vec2 dir = normalize(end - start);\r\n\r\n    vec2 localP = p - start;\r\n    float proj = dot(localP, dir);\r\n    float perpProj = dot(localP, vec2(-dir.y, dir.x));\r\n\r\n    float alongLine = clamp(proj, 0.0, length(end - start));\r\n    vec2 closestPoint = start + dir * alongLine;\r\n\r\n    float d = length(p - closestPoint) - radius;\r\n\r\n    float frequency = PI / length(end - start);\r\n    float sind = sin(frequency * alongLine);\r\n    sind = pow(sind, power);\r\n    sind *= depth*radius;\r\n    \r\n    return d + sind;\r\n}\r\n\r\n\r\n// stroke edge\r\nvoid stroke(float d, vec4 c, inout vec4 fragColor, float w)\r\n{\r\n    float m = 1.0-step(.5*w, abs(d));\r\n    fragColor = mix(fragColor, c, m*c.a);\r\n}\r\n\r\n// stroke edge with anti-aliasing\r\nvoid strokeAA(float d, vec4 c, inout vec4 fragColor, float w, float aa)\r\n{\r\n    float m = smoothstep(0.5 * (w + aa), 0.5 * (w - aa), abs(d));\r\n    fragColor = mix(fragColor, c, m*c.a);\r\n}\r\n\r\n// background color\r\n#define bg_c vec4(0.0, 0.0, 0.0, 1.0)\r\n\r\n// grid color\r\n#define grid_c vec4(.5, .5, .5, 1.0)\r\n\r\n// grid line width\r\n#define grid_w 2.0\r\n\r\n// grid vertical divisions\r\n// grid cross\r\n#define grid_s vec2(9.0, 0.0)                     \r\n\r\n// circlegrid color\r\n#define circlegrid_c vec4(0.5)\r\n\r\n// circlegrid line width\r\n// circlegrid size\r\n// circlegrid offset x\r\n// circle grid offset y\r\n#define circlegrid_s vec4(1.0, .25, 0.0, 0.0)\r\n\r\n// circle color\r\n#define circle_c vec4(1.0)\r\n\r\n// circle line width\r\n#define circle_w 2.0\r\n\r\n// TL to BR diagonal color\r\n#define diag1_c vec4(.5, 1.0, .75, 1.0)\r\n\r\n// BL to TR diagonal color\r\n#define diag2_c vec4(1.0, .5, .666, 1.0)\r\n\r\n// diagonal line width\r\n#define diag_w 2.0\r\n\r\n// horizontal centerline color\r\n#define centerh_c vec4(1.0, 1.0, .5, 1.0)\r\n\r\n// vertical centerline color\r\n#define centerv_c vec4(1.0, 1.0, .5, 1.0)\r\n\r\n// center line width\r\n#define center_w 2.0\r\n\r\n// rainbow line width\r\n// rainbow alpha\r\n// rainbow period\r\n// rainbow offset\r\n#define rainbow_s vec4(3.0, 1.0, 2.0, .17)\r\n\r\n// border color\r\n#define border_c vec4(.5, 1.0, .5, 1.0)\r\n\r\n// border line width\r\n#define border_w 2.0\r\n\r\n// logo color 1\r\n#define logo_c1 vec4(0.0, 0.0, 0.0, 1.0)\r\n\r\n// logo color 2\r\n#define logo_c2 vec4(1.0, 1.0, 1.0, 1.0)\r\n\r\n// logo color 3\r\n#define logo_c3 vec4(.5, 0.5, 0.5, 1.0)\r\n\r\n// logo type\r\n// logo size\r\n#define logo_s vec2(0.0, .1)\r\n\r\n// grid\r\nvoid grid(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    float gc = (1.0 - grid_s.y)*.5;\r\n    vec2 grid = p - round(p*grid_s.x)/grid_s.x;\r\n    grid *= grid_s.x;\r\n    float d = min(abs(grid.x), abs(grid.y));\r\n    vec2 cross = vec2(step(gc, abs(grid.x)), step(gc, abs(grid.y)));\r\n    d += max(cross.x, cross.y);\r\n    stroke(d, grid_c, fragColor, grid_s.x*grid_w*px_size);\r\n}\r\n\r\n// circle grid\r\nvoid circleGrid(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    p -= circlegrid_s.zw/grid_s.x;\r\n    vec2 cell = mod(p * vec2(grid_s.x), 1.0);\r\n    vec2 center = mod(vec2(.5), 1.0);\r\n    float radius = circlegrid_s.y;\r\n    vec2 dist = cell - center;\r\n    float d = length(dist) - radius;\r\n    strokeAA(d, circlegrid_c, fragColor, circlegrid_s.x*grid_s.x * px_size, length(fwidth(p*grid_s.x)));\r\n}\r\n\r\n// circle\r\nvoid circle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\r\n{\r\n    center = center + round(p);\r\n    \r\n    float d = length(p - center) - radius;\r\n    strokeAA(d, c, fragColor, circle_w * px_size, length(fwidth(p)));\r\n}\r\n\r\n// rainbow circle\r\nvoid rainbowCircle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\r\n{\r\n\tvec2 pq = vec2(atan(p.x, p.y) / TAU*rainbow_s.z + rainbow_s.w, length(p));\r\n\tfloat d = length(p - center) - radius;\r\n\tc = vec4(hsv2rgb(vec3(pq.x, 1., 1.)), 1.0);\r\n\tstrokeAA(d, c, fragColor, rainbow_s.x * px_size, length(fwidth(p)));\r\n}\r\n\r\n// horizontal center line\r\nvoid centerH(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\r\n    p = mod(p, 1.0)-.5;\r\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\r\n}\r\n\r\n// vertical center line\r\nvoid centerV(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    stroke(abs(p.y), centerv_c, fragColor, center_w*px_size);\r\n    p = mod(p, 1.0)-.5;\r\n    stroke(abs(p.y), centerh_c, fragColor, center_w*px_size);\r\n}\r\n\r\n// diagonal lines\r\nvoid diagonals(vec2 p, float px_size, float aspect, inout vec4 fragColor)\r\n{\r\n\tp += .5;\r\n\tp = mod(p, 1.0);\r\n\t//p = p - floor(p);\r\n\r\n\tfloat dist = abs(p.x - p.y);\r\n\tstrokeAA(dist, diag1_c, fragColor, diag_w*px_size, length(fwidth(p)));\r\n\t\r\n\tdist = abs(p.x + p.y)-1.0;\r\n\tstrokeAA(dist, diag2_c, fragColor, diag_w*px_size, length(fwidth(p)));\r\n\t//fragColor = vec4(vec3(dist), 1.0);\r\n}\r\n\r\n// render border\r\nvoid border(vec2 p, vec2 res, inout vec4 fragColor)\r\n{\r\n\tfloat d = min(min(p.x, 1.0-p.x)*res.x, min(p.y, 1.0-p.y)*res.y);\r\n\tfragColor = mix(fragColor, border_c, 1.0-step(border_w, d));\r\n}\r\n\r\n\r\n// mw logo\r\nvoid mwLogo(vec2 p, vec2 offset, float scale, float aspect, float px_size, inout vec4 fragColor)\r\n{\r\n\tp -= offset;\r\n\tp.y *= .6;\r\n\tp /= scale;\r\n\t\r\n\t\r\n\tfloat w = 20.0 * px_size;\r\n\t\r\n\tvec2 ra =vec2(0.5,0.5);\r\n\tfloat d1 = sdRhombus( vec2(p.x + .5, p.y), ra );\r\n\tfloat d2 = sdRhombus( vec2(p.x - .5, p.y), ra );\r\n\tfragColor = mix(fragColor, vec4(vec3(pow(min(d1+.95, d2+.95), 8.0)), 1.0)*logo_c3, (1.0-step(0.0, min(d1, d2)))*logo_c3.a);\r\n\tstrokeAA(min(d1, d2), logo_c2, fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.1, d2+.1), logo_c2 * vec4(0.8), fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.2, d2+.2), logo_c2 * vec4(0.6), fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.3, d2+.3), logo_c2 * vec4(0.4), fragColor, w, length(fwidth(p)));\r\n\t\r\n\tfloat d3 = sdSegment(p, vec2(1.0, 0.0), vec2(-1.0, 0.0));\r\n\tstrokeAA(d3, logo_c2, fragColor, w, length(fwidth(p)));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized pixel coordinates\r\n    vec2 vUV = fragCoord/iResolution.xy;\r\n    \r\n    \r\n    // resolution\r\n    vec2 res = iResolution.xy;\r\n    \r\n    // aspect ratio\r\n    float aspect = res.x / res.y;\r\n\t\r\n\t// -.5 to .5 coordinate space\r\n\tvec2 p = vUV.st-.5;\r\n\t\r\n\tvec2 logo_offset = vec2(0.0, 0.0);\r\n\t\r\n\t// pixel size\r\n\tfloat px_size = 0.0;\r\n\t\r\n\t// alignment for different aspect ratios\r\n\tif (aspect > 1.0)\r\n\t{\r\n\t\tp.x *= aspect;\r\n\t\tlogo_offset.x = (aspect>1.0+logo_s.y*2.0)?.5 : .25;\r\n\t\tpx_size = 1.0/res.y;\r\n\t} else {\r\n\t\tp.y /= aspect;\r\n\t\tlogo_offset.y = (aspect<1.0-logo_s.y*2.0)?.5 : .25;\r\n\t\tpx_size = 1.0/res.x;\r\n\t} \r\n\t\r\n\r\n\t\r\n\t// background color\r\n\tfragColor = bg_c;\r\n\t\r\n\t// square grid\r\n\tgrid(p, px_size, fragColor);\r\n\t\r\n\t// circle grid\r\n\tcircleGrid(p, px_size, fragColor);\r\n\t\r\n\t// big circles\r\n    circle(p, vec2(0), 0.5, circle_c, px_size, fragColor);\r\n    \r\n    // diagonal lines\r\n    diagonals(p, px_size, aspect, fragColor);\r\n    \r\n    // vertical center lines\r\n\tcenterV(p, px_size, fragColor);\r\n\t\r\n\t// horizontal center lines\r\n\tcenterH(p, px_size, fragColor);\r\n\t\r\n\t// rainbow circle\r\n    rainbowCircle(p, vec2(0), .333, vec4(1.0), px_size, fragColor);\r\n\r\n\t// border lines\r\n    //vec2 b_pos = vec2(vUV.x * aspect, vUV.y);\r\n    //b_pos = vUV.xy * res;\r\n    border(vUV.st, res, fragColor);\r\n    \r\n\r\n    // mw logo\r\n\tmwLogo(p, logo_offset, logo_s.y, aspect, px_size, fragColor);\r\n\tmwLogo(p, -logo_offset, logo_s.y, aspect, px_size, fragColor);\r\n\r\n\t\r\n\t//pxGrid(p, px_size, fragColor);\r\n}", "sourceMedias": {}}, {"parameters": [{"value": 1986, "hexMode": false, "controlAddress": "/width"}, {"value": "ShaderToy File", "controlAddress": "/shaderType"}, {"value": "C:/Users/ULTREIA/Desktop/grid.shader", "controlAddress": "/fragmentShader"}, {"value": "Mfs3D2", "controlAddress": "/shaderToyID"}, {"value": "Bd8jRr", "controlAddress": "/shaderToyKey"}, {"value": false, "controlAddress": "/keepOfflineCache"}, {"value": [1.0, 1.0, 1.0, 1.0], "controlAddress": "/backgroundColor"}], "niceName": "Test Pattern Cour", "containers": {"mediaParameters": {}, "sourceMedias": {}}, "type": "Shader", "shaderCache": "// \u00cd\u00f1igo Qu\u00edlez\r\n// https://iquilezles.org/articles/distfunctions2d/\r\n#define     TAU 6.28318530717958647 // pi * 2\r\n#define     PI  3.14159265358979323 // pi\r\n\r\n// hsv to rgb\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\r\n  rgb = rgb * rgb * (3. - 2. * rgb);\r\n  return c.z * mix(vec3(1.), rgb, c.y);\r\n}\r\n\r\n// sd polygon\r\nconst int N = 8;\r\nfloat sdPolygon( in vec2 p, in vec2[N] v )\r\n{\r\n    int num = v.length();\r\n    float d = dot(p-v[0],p-v[0]);\r\n    float s = 1.0;\r\n    for( int i=0, j=num-1; i<num; j=i, i++ )\r\n    {\r\n        // distance\r\n        vec2 e = v[j] - v[i];\r\n        vec2 w =    p - v[i];\r\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\r\n        d = min( d, dot(b,b) );\r\n\r\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\r\n        bvec3 cond = bvec3( p.y>=v[i].y, \r\n                            p.y <v[j].y, \r\n                            e.x*w.y>e.y*w.x );\r\n        if( all(cond) || all(not(cond)) ) s=-s;  \r\n    }\r\n    \r\n    return s*sqrt(d);\r\n}\r\n\r\n// sd segment\r\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p-a, ba = b-a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    return length( pa - ba*h );\r\n}\r\n\r\n// sd box\r\nfloat sdBox( vec2 p, vec2 b, vec2 o)\r\n{\r\n    p -= o;\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\n// sd circle\r\nfloat sdCircle( vec2 p, float r )\r\n{\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\r\n\r\n// sd rhombus\r\nfloat sdRhombus( in vec2 p, in vec2 b ) \r\n{\r\n    p = abs(p);\r\n\r\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\r\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\r\n\r\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\r\n}\r\n\r\n// sd distorted pill\r\nfloat sdDistortedPill(vec2 p, vec2 start, vec2 end, float radius, float power, float depth)\r\n{\r\n    p = -p;\r\n    vec2 dir = normalize(end - start);\r\n\r\n    vec2 localP = p - start;\r\n    float proj = dot(localP, dir);\r\n    float perpProj = dot(localP, vec2(-dir.y, dir.x));\r\n\r\n    float alongLine = clamp(proj, 0.0, length(end - start));\r\n    vec2 closestPoint = start + dir * alongLine;\r\n\r\n    float d = length(p - closestPoint) - radius;\r\n\r\n    float frequency = PI / length(end - start);\r\n    float sind = sin(frequency * alongLine);\r\n    sind = pow(sind, power);\r\n    sind *= depth*radius;\r\n    \r\n    return d + sind;\r\n}\r\n\r\n\r\n// stroke edge\r\nvoid stroke(float d, vec4 c, inout vec4 fragColor, float w)\r\n{\r\n    float m = 1.0-step(.5*w, abs(d));\r\n    fragColor = mix(fragColor, c, m*c.a);\r\n}\r\n\r\n// stroke edge with anti-aliasing\r\nvoid strokeAA(float d, vec4 c, inout vec4 fragColor, float w, float aa)\r\n{\r\n    float m = smoothstep(0.5 * (w + aa), 0.5 * (w - aa), abs(d));\r\n    fragColor = mix(fragColor, c, m*c.a);\r\n}\r\n\r\n// background color\r\n#define bg_c vec4(0.0, 0.0, 0.0, 1.0)\r\n\r\n// grid color\r\n#define grid_c vec4(.5, .5, .5, 1.0)\r\n\r\n// grid line width\r\n#define grid_w 2.0\r\n\r\n// grid vertical divisions\r\n// grid cross\r\n#define grid_s vec2(9.0, 0.0)                     \r\n\r\n// circlegrid color\r\n#define circlegrid_c vec4(0.5)\r\n\r\n// circlegrid line width\r\n// circlegrid size\r\n// circlegrid offset x\r\n// circle grid offset y\r\n#define circlegrid_s vec4(1.0, .25, 0.0, 0.0)\r\n\r\n// circle color\r\n#define circle_c vec4(1.0)\r\n\r\n// circle line width\r\n#define circle_w 2.0\r\n\r\n// TL to BR diagonal color\r\n#define diag1_c vec4(.5, 1.0, .75, 1.0)\r\n\r\n// BL to TR diagonal color\r\n#define diag2_c vec4(1.0, .5, .666, 1.0)\r\n\r\n// diagonal line width\r\n#define diag_w 2.0\r\n\r\n// horizontal centerline color\r\n#define centerh_c vec4(1.0, 1.0, .5, 1.0)\r\n\r\n// vertical centerline color\r\n#define centerv_c vec4(1.0, 1.0, .5, 1.0)\r\n\r\n// center line width\r\n#define center_w 2.0\r\n\r\n// rainbow line width\r\n// rainbow alpha\r\n// rainbow period\r\n// rainbow offset\r\n#define rainbow_s vec4(3.0, 1.0, 2.0, .17)\r\n\r\n// border color\r\n#define border_c vec4(.5, 1.0, .5, 1.0)\r\n\r\n// border line width\r\n#define border_w 2.0\r\n\r\n// logo color 1\r\n#define logo_c1 vec4(0.0, 0.0, 0.0, 1.0)\r\n\r\n// logo color 2\r\n#define logo_c2 vec4(1.0, 1.0, 1.0, 1.0)\r\n\r\n// logo color 3\r\n#define logo_c3 vec4(.5, 0.5, 0.5, 1.0)\r\n\r\n// logo type\r\n// logo size\r\n#define logo_s vec2(0.0, .1)\r\n\r\n// grid\r\nvoid grid(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    float gc = (1.0 - grid_s.y)*.5;\r\n    vec2 grid = p - round(p*grid_s.x)/grid_s.x;\r\n    grid *= grid_s.x;\r\n    float d = min(abs(grid.x), abs(grid.y));\r\n    vec2 cross = vec2(step(gc, abs(grid.x)), step(gc, abs(grid.y)));\r\n    d += max(cross.x, cross.y);\r\n    stroke(d, grid_c, fragColor, grid_s.x*grid_w*px_size);\r\n}\r\n\r\n// circle grid\r\nvoid circleGrid(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    p -= circlegrid_s.zw/grid_s.x;\r\n    vec2 cell = mod(p * vec2(grid_s.x), 1.0);\r\n    vec2 center = mod(vec2(.5), 1.0);\r\n    float radius = circlegrid_s.y;\r\n    vec2 dist = cell - center;\r\n    float d = length(dist) - radius;\r\n    strokeAA(d, circlegrid_c, fragColor, circlegrid_s.x*grid_s.x * px_size, length(fwidth(p*grid_s.x)));\r\n}\r\n\r\n// circle\r\nvoid circle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\r\n{\r\n    center = center + round(p);\r\n    \r\n    float d = length(p - center) - radius;\r\n    strokeAA(d, c, fragColor, circle_w * px_size, length(fwidth(p)));\r\n}\r\n\r\n// rainbow circle\r\nvoid rainbowCircle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\r\n{\r\n\tvec2 pq = vec2(atan(p.x, p.y) / TAU*rainbow_s.z + rainbow_s.w, length(p));\r\n\tfloat d = length(p - center) - radius;\r\n\tc = vec4(hsv2rgb(vec3(pq.x, 1., 1.)), 1.0);\r\n\tstrokeAA(d, c, fragColor, rainbow_s.x * px_size, length(fwidth(p)));\r\n}\r\n\r\n// horizontal center line\r\nvoid centerH(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\r\n    p = mod(p, 1.0)-.5;\r\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\r\n}\r\n\r\n// vertical center line\r\nvoid centerV(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    stroke(abs(p.y), centerv_c, fragColor, center_w*px_size);\r\n    p = mod(p, 1.0)-.5;\r\n    stroke(abs(p.y), centerh_c, fragColor, center_w*px_size);\r\n}\r\n\r\n// diagonal lines\r\nvoid diagonals(vec2 p, float px_size, float aspect, inout vec4 fragColor)\r\n{\r\n\tp += .5;\r\n\tp = mod(p, 1.0);\r\n\t//p = p - floor(p);\r\n\r\n\tfloat dist = abs(p.x - p.y);\r\n\tstrokeAA(dist, diag1_c, fragColor, diag_w*px_size, length(fwidth(p)));\r\n\t\r\n\tdist = abs(p.x + p.y)-1.0;\r\n\tstrokeAA(dist, diag2_c, fragColor, diag_w*px_size, length(fwidth(p)));\r\n\t//fragColor = vec4(vec3(dist), 1.0);\r\n}\r\n\r\n// render border\r\nvoid border(vec2 p, vec2 res, inout vec4 fragColor)\r\n{\r\n\tfloat d = min(min(p.x, 1.0-p.x)*res.x, min(p.y, 1.0-p.y)*res.y);\r\n\tfragColor = mix(fragColor, border_c, 1.0-step(border_w, d));\r\n}\r\n\r\n\r\n// mw logo\r\nvoid mwLogo(vec2 p, vec2 offset, float scale, float aspect, float px_size, inout vec4 fragColor)\r\n{\r\n\tp -= offset;\r\n\tp.y *= .6;\r\n\tp /= scale;\r\n\t\r\n\t\r\n\tfloat w = 20.0 * px_size;\r\n\t\r\n\tvec2 ra =vec2(0.5,0.5);\r\n\tfloat d1 = sdRhombus( vec2(p.x + .5, p.y), ra );\r\n\tfloat d2 = sdRhombus( vec2(p.x - .5, p.y), ra );\r\n\tfragColor = mix(fragColor, vec4(vec3(pow(min(d1+.95, d2+.95), 8.0)), 1.0)*logo_c3, (1.0-step(0.0, min(d1, d2)))*logo_c3.a);\r\n\tstrokeAA(min(d1, d2), logo_c2, fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.1, d2+.1), logo_c2 * vec4(0.8), fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.2, d2+.2), logo_c2 * vec4(0.6), fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.3, d2+.3), logo_c2 * vec4(0.4), fragColor, w, length(fwidth(p)));\r\n\t\r\n\tfloat d3 = sdSegment(p, vec2(1.0, 0.0), vec2(-1.0, 0.0));\r\n\tstrokeAA(d3, logo_c2, fragColor, w, length(fwidth(p)));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized pixel coordinates\r\n    vec2 vUV = fragCoord/iResolution.xy;\r\n    \r\n    \r\n    // resolution\r\n    vec2 res = iResolution.xy;\r\n    \r\n    // aspect ratio\r\n    float aspect = res.x / res.y;\r\n\t\r\n\t// -.5 to .5 coordinate space\r\n\tvec2 p = vUV.st-.5;\r\n\t\r\n\tvec2 logo_offset = vec2(0.0, 0.0);\r\n\t\r\n\t// pixel size\r\n\tfloat px_size = 0.0;\r\n\t\r\n\t// alignment for different aspect ratios\r\n\tif (aspect > 1.0)\r\n\t{\r\n\t\tp.x *= aspect;\r\n\t\tlogo_offset.x = (aspect>1.0+logo_s.y*2.0)?.5 : .25;\r\n\t\tpx_size = 1.0/res.y;\r\n\t} else {\r\n\t\tp.y /= aspect;\r\n\t\tlogo_offset.y = (aspect<1.0-logo_s.y*2.0)?.5 : .25;\r\n\t\tpx_size = 1.0/res.x;\r\n\t} \r\n\t\r\n\r\n\t\r\n\t// background color\r\n\tfragColor = bg_c;\r\n\t\r\n\t// square grid\r\n\tgrid(p, px_size, fragColor);\r\n\t\r\n\t// circle grid\r\n\tcircleGrid(p, px_size, fragColor);\r\n\t\r\n\t// big circles\r\n    circle(p, vec2(0), 0.5, circle_c, px_size, fragColor);\r\n    \r\n    // diagonal lines\r\n    diagonals(p, px_size, aspect, fragColor);\r\n    \r\n    // vertical center lines\r\n\tcenterV(p, px_size, fragColor);\r\n\t\r\n\t// horizontal center lines\r\n\tcenterH(p, px_size, fragColor);\r\n\t\r\n\t// rainbow circle\r\n    rainbowCircle(p, vec2(0), .333, vec4(1.0), px_size, fragColor);\r\n\r\n\t// border lines\r\n    //vec2 b_pos = vec2(vUV.x * aspect, vUV.y);\r\n    //b_pos = vUV.xy * res;\r\n    border(vUV.st, res, fragColor);\r\n    \r\n\r\n    // mw logo\r\n\tmwLogo(p, logo_offset, logo_s.y, aspect, px_size, fragColor);\r\n\tmwLogo(p, -logo_offset, logo_s.y, aspect, px_size, fragColor);\r\n\r\n\t\r\n\t//pxGrid(p, px_size, fragColor);\r\n}", "sourceMedias": {}}, {"parameters": [{"value": 1400, "hexMode": false, "controlAddress": "/width"}, {"value": 924, "hexMode": false, "controlAddress": "/height"}, {"value": "ShaderToy File", "controlAddress": "/shaderType"}, {"value": "C:/Users/ULTREIA/Desktop/grid.shader", "controlAddress": "/fragmentShader"}, {"value": "Mfs3D2", "controlAddress": "/shaderToyID"}, {"value": "Bd8jRr", "controlAddress": "/shaderToyKey"}, {"value": false, "controlAddress": "/keepOfflineCache"}, {"value": [1.0, 1.0, 1.0, 1.0], "controlAddress": "/backgroundColor"}], "niceName": "Test Pattern Jar Front", "containers": {"mediaParameters": {}, "sourceMedias": {}}, "type": "Shader", "shaderCache": "// \u00cd\u00f1igo Qu\u00edlez\r\n// https://iquilezles.org/articles/distfunctions2d/\r\n#define     TAU 6.28318530717958647 // pi * 2\r\n#define     PI  3.14159265358979323 // pi\r\n\r\n// hsv to rgb\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\r\n  rgb = rgb * rgb * (3. - 2. * rgb);\r\n  return c.z * mix(vec3(1.), rgb, c.y);\r\n}\r\n\r\n// sd polygon\r\nconst int N = 8;\r\nfloat sdPolygon( in vec2 p, in vec2[N] v )\r\n{\r\n    int num = v.length();\r\n    float d = dot(p-v[0],p-v[0]);\r\n    float s = 1.0;\r\n    for( int i=0, j=num-1; i<num; j=i, i++ )\r\n    {\r\n        // distance\r\n        vec2 e = v[j] - v[i];\r\n        vec2 w =    p - v[i];\r\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\r\n        d = min( d, dot(b,b) );\r\n\r\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\r\n        bvec3 cond = bvec3( p.y>=v[i].y, \r\n                            p.y <v[j].y, \r\n                            e.x*w.y>e.y*w.x );\r\n        if( all(cond) || all(not(cond)) ) s=-s;  \r\n    }\r\n    \r\n    return s*sqrt(d);\r\n}\r\n\r\n// sd segment\r\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p-a, ba = b-a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    return length( pa - ba*h );\r\n}\r\n\r\n// sd box\r\nfloat sdBox( vec2 p, vec2 b, vec2 o)\r\n{\r\n    p -= o;\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\n// sd circle\r\nfloat sdCircle( vec2 p, float r )\r\n{\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\r\n\r\n// sd rhombus\r\nfloat sdRhombus( in vec2 p, in vec2 b ) \r\n{\r\n    p = abs(p);\r\n\r\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\r\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\r\n\r\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\r\n}\r\n\r\n// sd distorted pill\r\nfloat sdDistortedPill(vec2 p, vec2 start, vec2 end, float radius, float power, float depth)\r\n{\r\n    p = -p;\r\n    vec2 dir = normalize(end - start);\r\n\r\n    vec2 localP = p - start;\r\n    float proj = dot(localP, dir);\r\n    float perpProj = dot(localP, vec2(-dir.y, dir.x));\r\n\r\n    float alongLine = clamp(proj, 0.0, length(end - start));\r\n    vec2 closestPoint = start + dir * alongLine;\r\n\r\n    float d = length(p - closestPoint) - radius;\r\n\r\n    float frequency = PI / length(end - start);\r\n    float sind = sin(frequency * alongLine);\r\n    sind = pow(sind, power);\r\n    sind *= depth*radius;\r\n    \r\n    return d + sind;\r\n}\r\n\r\n\r\n// stroke edge\r\nvoid stroke(float d, vec4 c, inout vec4 fragColor, float w)\r\n{\r\n    float m = 1.0-step(.5*w, abs(d));\r\n    fragColor = mix(fragColor, c, m*c.a);\r\n}\r\n\r\n// stroke edge with anti-aliasing\r\nvoid strokeAA(float d, vec4 c, inout vec4 fragColor, float w, float aa)\r\n{\r\n    float m = smoothstep(0.5 * (w + aa), 0.5 * (w - aa), abs(d));\r\n    fragColor = mix(fragColor, c, m*c.a);\r\n}\r\n\r\n// background color\r\n#define bg_c vec4(0.0, 0.0, 0.0, 1.0)\r\n\r\n// grid color\r\n#define grid_c vec4(.5, .5, .5, 1.0)\r\n\r\n// grid line width\r\n#define grid_w 2.0\r\n\r\n// grid vertical divisions\r\n// grid cross\r\n#define grid_s vec2(9.0, 0.0)                     \r\n\r\n// circlegrid color\r\n#define circlegrid_c vec4(0.5)\r\n\r\n// circlegrid line width\r\n// circlegrid size\r\n// circlegrid offset x\r\n// circle grid offset y\r\n#define circlegrid_s vec4(1.0, .25, 0.0, 0.0)\r\n\r\n// circle color\r\n#define circle_c vec4(1.0)\r\n\r\n// circle line width\r\n#define circle_w 2.0\r\n\r\n// TL to BR diagonal color\r\n#define diag1_c vec4(.5, 1.0, .75, 1.0)\r\n\r\n// BL to TR diagonal color\r\n#define diag2_c vec4(1.0, .5, .666, 1.0)\r\n\r\n// diagonal line width\r\n#define diag_w 2.0\r\n\r\n// horizontal centerline color\r\n#define centerh_c vec4(1.0, 1.0, .5, 1.0)\r\n\r\n// vertical centerline color\r\n#define centerv_c vec4(1.0, 1.0, .5, 1.0)\r\n\r\n// center line width\r\n#define center_w 2.0\r\n\r\n// rainbow line width\r\n// rainbow alpha\r\n// rainbow period\r\n// rainbow offset\r\n#define rainbow_s vec4(3.0, 1.0, 2.0, .17)\r\n\r\n// border color\r\n#define border_c vec4(.5, 1.0, .5, 1.0)\r\n\r\n// border line width\r\n#define border_w 2.0\r\n\r\n// logo color 1\r\n#define logo_c1 vec4(0.0, 0.0, 0.0, 1.0)\r\n\r\n// logo color 2\r\n#define logo_c2 vec4(1.0, 1.0, 1.0, 1.0)\r\n\r\n// logo color 3\r\n#define logo_c3 vec4(.5, 0.5, 0.5, 1.0)\r\n\r\n// logo type\r\n// logo size\r\n#define logo_s vec2(0.0, .1)\r\n\r\n// grid\r\nvoid grid(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    float gc = (1.0 - grid_s.y)*.5;\r\n    vec2 grid = p - round(p*grid_s.x)/grid_s.x;\r\n    grid *= grid_s.x;\r\n    float d = min(abs(grid.x), abs(grid.y));\r\n    vec2 cross = vec2(step(gc, abs(grid.x)), step(gc, abs(grid.y)));\r\n    d += max(cross.x, cross.y);\r\n    stroke(d, grid_c, fragColor, grid_s.x*grid_w*px_size);\r\n}\r\n\r\n// circle grid\r\nvoid circleGrid(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    p -= circlegrid_s.zw/grid_s.x;\r\n    vec2 cell = mod(p * vec2(grid_s.x), 1.0);\r\n    vec2 center = mod(vec2(.5), 1.0);\r\n    float radius = circlegrid_s.y;\r\n    vec2 dist = cell - center;\r\n    float d = length(dist) - radius;\r\n    strokeAA(d, circlegrid_c, fragColor, circlegrid_s.x*grid_s.x * px_size, length(fwidth(p*grid_s.x)));\r\n}\r\n\r\n// circle\r\nvoid circle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\r\n{\r\n    center = center + round(p);\r\n    \r\n    float d = length(p - center) - radius;\r\n    strokeAA(d, c, fragColor, circle_w * px_size, length(fwidth(p)));\r\n}\r\n\r\n// rainbow circle\r\nvoid rainbowCircle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\r\n{\r\n\tvec2 pq = vec2(atan(p.x, p.y) / TAU*rainbow_s.z + rainbow_s.w, length(p));\r\n\tfloat d = length(p - center) - radius;\r\n\tc = vec4(hsv2rgb(vec3(pq.x, 1., 1.)), 1.0);\r\n\tstrokeAA(d, c, fragColor, rainbow_s.x * px_size, length(fwidth(p)));\r\n}\r\n\r\n// horizontal center line\r\nvoid centerH(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\r\n    p = mod(p, 1.0)-.5;\r\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\r\n}\r\n\r\n// vertical center line\r\nvoid centerV(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    stroke(abs(p.y), centerv_c, fragColor, center_w*px_size);\r\n    p = mod(p, 1.0)-.5;\r\n    stroke(abs(p.y), centerh_c, fragColor, center_w*px_size);\r\n}\r\n\r\n// diagonal lines\r\nvoid diagonals(vec2 p, float px_size, float aspect, inout vec4 fragColor)\r\n{\r\n\tp += .5;\r\n\tp = mod(p, 1.0);\r\n\t//p = p - floor(p);\r\n\r\n\tfloat dist = abs(p.x - p.y);\r\n\tstrokeAA(dist, diag1_c, fragColor, diag_w*px_size, length(fwidth(p)));\r\n\t\r\n\tdist = abs(p.x + p.y)-1.0;\r\n\tstrokeAA(dist, diag2_c, fragColor, diag_w*px_size, length(fwidth(p)));\r\n\t//fragColor = vec4(vec3(dist), 1.0);\r\n}\r\n\r\n// render border\r\nvoid border(vec2 p, vec2 res, inout vec4 fragColor)\r\n{\r\n\tfloat d = min(min(p.x, 1.0-p.x)*res.x, min(p.y, 1.0-p.y)*res.y);\r\n\tfragColor = mix(fragColor, border_c, 1.0-step(border_w, d));\r\n}\r\n\r\n\r\n// mw logo\r\nvoid mwLogo(vec2 p, vec2 offset, float scale, float aspect, float px_size, inout vec4 fragColor)\r\n{\r\n\tp -= offset;\r\n\tp.y *= .6;\r\n\tp /= scale;\r\n\t\r\n\t\r\n\tfloat w = 20.0 * px_size;\r\n\t\r\n\tvec2 ra =vec2(0.5,0.5);\r\n\tfloat d1 = sdRhombus( vec2(p.x + .5, p.y), ra );\r\n\tfloat d2 = sdRhombus( vec2(p.x - .5, p.y), ra );\r\n\tfragColor = mix(fragColor, vec4(vec3(pow(min(d1+.95, d2+.95), 8.0)), 1.0)*logo_c3, (1.0-step(0.0, min(d1, d2)))*logo_c3.a);\r\n\tstrokeAA(min(d1, d2), logo_c2, fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.1, d2+.1), logo_c2 * vec4(0.8), fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.2, d2+.2), logo_c2 * vec4(0.6), fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.3, d2+.3), logo_c2 * vec4(0.4), fragColor, w, length(fwidth(p)));\r\n\t\r\n\tfloat d3 = sdSegment(p, vec2(1.0, 0.0), vec2(-1.0, 0.0));\r\n\tstrokeAA(d3, logo_c2, fragColor, w, length(fwidth(p)));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized pixel coordinates\r\n    vec2 vUV = fragCoord/iResolution.xy;\r\n    \r\n    \r\n    // resolution\r\n    vec2 res = iResolution.xy;\r\n    \r\n    // aspect ratio\r\n    float aspect = res.x / res.y;\r\n\t\r\n\t// -.5 to .5 coordinate space\r\n\tvec2 p = vUV.st-.5;\r\n\t\r\n\tvec2 logo_offset = vec2(0.0, 0.0);\r\n\t\r\n\t// pixel size\r\n\tfloat px_size = 0.0;\r\n\t\r\n\t// alignment for different aspect ratios\r\n\tif (aspect > 1.0)\r\n\t{\r\n\t\tp.x *= aspect;\r\n\t\tlogo_offset.x = (aspect>1.0+logo_s.y*2.0)?.5 : .25;\r\n\t\tpx_size = 1.0/res.y;\r\n\t} else {\r\n\t\tp.y /= aspect;\r\n\t\tlogo_offset.y = (aspect<1.0-logo_s.y*2.0)?.5 : .25;\r\n\t\tpx_size = 1.0/res.x;\r\n\t} \r\n\t\r\n\r\n\t\r\n\t// background color\r\n\tfragColor = bg_c;\r\n\t\r\n\t// square grid\r\n\tgrid(p, px_size, fragColor);\r\n\t\r\n\t// circle grid\r\n\tcircleGrid(p, px_size, fragColor);\r\n\t\r\n\t// big circles\r\n    circle(p, vec2(0), 0.5, circle_c, px_size, fragColor);\r\n    \r\n    // diagonal lines\r\n    diagonals(p, px_size, aspect, fragColor);\r\n    \r\n    // vertical center lines\r\n\tcenterV(p, px_size, fragColor);\r\n\t\r\n\t// horizontal center lines\r\n\tcenterH(p, px_size, fragColor);\r\n\t\r\n\t// rainbow circle\r\n    rainbowCircle(p, vec2(0), .333, vec4(1.0), px_size, fragColor);\r\n\r\n\t// border lines\r\n    //vec2 b_pos = vec2(vUV.x * aspect, vUV.y);\r\n    //b_pos = vUV.xy * res;\r\n    border(vUV.st, res, fragColor);\r\n    \r\n\r\n    // mw logo\r\n\tmwLogo(p, logo_offset, logo_s.y, aspect, px_size, fragColor);\r\n\tmwLogo(p, -logo_offset, logo_s.y, aspect, px_size, fragColor);\r\n\r\n\t\r\n\t//pxGrid(p, px_size, fragColor);\r\n}", "sourceMedias": {}}, {"parameters": [{"value": 580, "hexMode": false, "controlAddress": "/width"}, {"value": 820, "hexMode": false, "controlAddress": "/height"}, {"value": "ShaderToy File", "controlAddress": "/shaderType"}, {"value": "C:/Users/ULTREIA/Desktop/grid.shader", "controlAddress": "/fragmentShader"}, {"value": "Mfs3D2", "controlAddress": "/shaderToyID"}, {"value": "Bd8jRr", "controlAddress": "/shaderToyKey"}, {"value": false, "controlAddress": "/keepOfflineCache"}, {"value": [1.0, 1.0, 1.0, 1.0], "controlAddress": "/backgroundColor"}], "niceName": "Test Pattern Jar Back", "containers": {"mediaParameters": {}, "sourceMedias": {}}, "type": "Shader", "shaderCache": "// \u00cd\u00f1igo Qu\u00edlez\r\n// https://iquilezles.org/articles/distfunctions2d/\r\n#define     TAU 6.28318530717958647 // pi * 2\r\n#define     PI  3.14159265358979323 // pi\r\n\r\n// hsv to rgb\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\r\n  rgb = rgb * rgb * (3. - 2. * rgb);\r\n  return c.z * mix(vec3(1.), rgb, c.y);\r\n}\r\n\r\n// sd polygon\r\nconst int N = 8;\r\nfloat sdPolygon( in vec2 p, in vec2[N] v )\r\n{\r\n    int num = v.length();\r\n    float d = dot(p-v[0],p-v[0]);\r\n    float s = 1.0;\r\n    for( int i=0, j=num-1; i<num; j=i, i++ )\r\n    {\r\n        // distance\r\n        vec2 e = v[j] - v[i];\r\n        vec2 w =    p - v[i];\r\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\r\n        d = min( d, dot(b,b) );\r\n\r\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\r\n        bvec3 cond = bvec3( p.y>=v[i].y, \r\n                            p.y <v[j].y, \r\n                            e.x*w.y>e.y*w.x );\r\n        if( all(cond) || all(not(cond)) ) s=-s;  \r\n    }\r\n    \r\n    return s*sqrt(d);\r\n}\r\n\r\n// sd segment\r\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p-a, ba = b-a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    return length( pa - ba*h );\r\n}\r\n\r\n// sd box\r\nfloat sdBox( vec2 p, vec2 b, vec2 o)\r\n{\r\n    p -= o;\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\n// sd circle\r\nfloat sdCircle( vec2 p, float r )\r\n{\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\r\n\r\n// sd rhombus\r\nfloat sdRhombus( in vec2 p, in vec2 b ) \r\n{\r\n    p = abs(p);\r\n\r\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\r\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\r\n\r\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\r\n}\r\n\r\n// sd distorted pill\r\nfloat sdDistortedPill(vec2 p, vec2 start, vec2 end, float radius, float power, float depth)\r\n{\r\n    p = -p;\r\n    vec2 dir = normalize(end - start);\r\n\r\n    vec2 localP = p - start;\r\n    float proj = dot(localP, dir);\r\n    float perpProj = dot(localP, vec2(-dir.y, dir.x));\r\n\r\n    float alongLine = clamp(proj, 0.0, length(end - start));\r\n    vec2 closestPoint = start + dir * alongLine;\r\n\r\n    float d = length(p - closestPoint) - radius;\r\n\r\n    float frequency = PI / length(end - start);\r\n    float sind = sin(frequency * alongLine);\r\n    sind = pow(sind, power);\r\n    sind *= depth*radius;\r\n    \r\n    return d + sind;\r\n}\r\n\r\n\r\n// stroke edge\r\nvoid stroke(float d, vec4 c, inout vec4 fragColor, float w)\r\n{\r\n    float m = 1.0-step(.5*w, abs(d));\r\n    fragColor = mix(fragColor, c, m*c.a);\r\n}\r\n\r\n// stroke edge with anti-aliasing\r\nvoid strokeAA(float d, vec4 c, inout vec4 fragColor, float w, float aa)\r\n{\r\n    float m = smoothstep(0.5 * (w + aa), 0.5 * (w - aa), abs(d));\r\n    fragColor = mix(fragColor, c, m*c.a);\r\n}\r\n\r\n// background color\r\n#define bg_c vec4(0.0, 0.0, 0.0, 1.0)\r\n\r\n// grid color\r\n#define grid_c vec4(.5, .5, .5, 1.0)\r\n\r\n// grid line width\r\n#define grid_w 2.0\r\n\r\n// grid vertical divisions\r\n// grid cross\r\n#define grid_s vec2(9.0, 0.0)                     \r\n\r\n// circlegrid color\r\n#define circlegrid_c vec4(0.5)\r\n\r\n// circlegrid line width\r\n// circlegrid size\r\n// circlegrid offset x\r\n// circle grid offset y\r\n#define circlegrid_s vec4(1.0, .25, 0.0, 0.0)\r\n\r\n// circle color\r\n#define circle_c vec4(1.0)\r\n\r\n// circle line width\r\n#define circle_w 2.0\r\n\r\n// TL to BR diagonal color\r\n#define diag1_c vec4(.5, 1.0, .75, 1.0)\r\n\r\n// BL to TR diagonal color\r\n#define diag2_c vec4(1.0, .5, .666, 1.0)\r\n\r\n// diagonal line width\r\n#define diag_w 2.0\r\n\r\n// horizontal centerline color\r\n#define centerh_c vec4(1.0, 1.0, .5, 1.0)\r\n\r\n// vertical centerline color\r\n#define centerv_c vec4(1.0, 1.0, .5, 1.0)\r\n\r\n// center line width\r\n#define center_w 2.0\r\n\r\n// rainbow line width\r\n// rainbow alpha\r\n// rainbow period\r\n// rainbow offset\r\n#define rainbow_s vec4(3.0, 1.0, 2.0, .17)\r\n\r\n// border color\r\n#define border_c vec4(.5, 1.0, .5, 1.0)\r\n\r\n// border line width\r\n#define border_w 2.0\r\n\r\n// logo color 1\r\n#define logo_c1 vec4(0.0, 0.0, 0.0, 1.0)\r\n\r\n// logo color 2\r\n#define logo_c2 vec4(1.0, 1.0, 1.0, 1.0)\r\n\r\n// logo color 3\r\n#define logo_c3 vec4(.5, 0.5, 0.5, 1.0)\r\n\r\n// logo type\r\n// logo size\r\n#define logo_s vec2(0.0, .1)\r\n\r\n// grid\r\nvoid grid(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    float gc = (1.0 - grid_s.y)*.5;\r\n    vec2 grid = p - round(p*grid_s.x)/grid_s.x;\r\n    grid *= grid_s.x;\r\n    float d = min(abs(grid.x), abs(grid.y));\r\n    vec2 cross = vec2(step(gc, abs(grid.x)), step(gc, abs(grid.y)));\r\n    d += max(cross.x, cross.y);\r\n    stroke(d, grid_c, fragColor, grid_s.x*grid_w*px_size);\r\n}\r\n\r\n// circle grid\r\nvoid circleGrid(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    p -= circlegrid_s.zw/grid_s.x;\r\n    vec2 cell = mod(p * vec2(grid_s.x), 1.0);\r\n    vec2 center = mod(vec2(.5), 1.0);\r\n    float radius = circlegrid_s.y;\r\n    vec2 dist = cell - center;\r\n    float d = length(dist) - radius;\r\n    strokeAA(d, circlegrid_c, fragColor, circlegrid_s.x*grid_s.x * px_size, length(fwidth(p*grid_s.x)));\r\n}\r\n\r\n// circle\r\nvoid circle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\r\n{\r\n    center = center + round(p);\r\n    \r\n    float d = length(p - center) - radius;\r\n    strokeAA(d, c, fragColor, circle_w * px_size, length(fwidth(p)));\r\n}\r\n\r\n// rainbow circle\r\nvoid rainbowCircle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\r\n{\r\n\tvec2 pq = vec2(atan(p.x, p.y) / TAU*rainbow_s.z + rainbow_s.w, length(p));\r\n\tfloat d = length(p - center) - radius;\r\n\tc = vec4(hsv2rgb(vec3(pq.x, 1., 1.)), 1.0);\r\n\tstrokeAA(d, c, fragColor, rainbow_s.x * px_size, length(fwidth(p)));\r\n}\r\n\r\n// horizontal center line\r\nvoid centerH(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\r\n    p = mod(p, 1.0)-.5;\r\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\r\n}\r\n\r\n// vertical center line\r\nvoid centerV(vec2 p, float px_size, inout vec4 fragColor)\r\n{\r\n    stroke(abs(p.y), centerv_c, fragColor, center_w*px_size);\r\n    p = mod(p, 1.0)-.5;\r\n    stroke(abs(p.y), centerh_c, fragColor, center_w*px_size);\r\n}\r\n\r\n// diagonal lines\r\nvoid diagonals(vec2 p, float px_size, float aspect, inout vec4 fragColor)\r\n{\r\n\tp += .5;\r\n\tp = mod(p, 1.0);\r\n\t//p = p - floor(p);\r\n\r\n\tfloat dist = abs(p.x - p.y);\r\n\tstrokeAA(dist, diag1_c, fragColor, diag_w*px_size, length(fwidth(p)));\r\n\t\r\n\tdist = abs(p.x + p.y)-1.0;\r\n\tstrokeAA(dist, diag2_c, fragColor, diag_w*px_size, length(fwidth(p)));\r\n\t//fragColor = vec4(vec3(dist), 1.0);\r\n}\r\n\r\n// render border\r\nvoid border(vec2 p, vec2 res, inout vec4 fragColor)\r\n{\r\n\tfloat d = min(min(p.x, 1.0-p.x)*res.x, min(p.y, 1.0-p.y)*res.y);\r\n\tfragColor = mix(fragColor, border_c, 1.0-step(border_w, d));\r\n}\r\n\r\n\r\n// mw logo\r\nvoid mwLogo(vec2 p, vec2 offset, float scale, float aspect, float px_size, inout vec4 fragColor)\r\n{\r\n\tp -= offset;\r\n\tp.y *= .6;\r\n\tp /= scale;\r\n\t\r\n\t\r\n\tfloat w = 20.0 * px_size;\r\n\t\r\n\tvec2 ra =vec2(0.5,0.5);\r\n\tfloat d1 = sdRhombus( vec2(p.x + .5, p.y), ra );\r\n\tfloat d2 = sdRhombus( vec2(p.x - .5, p.y), ra );\r\n\tfragColor = mix(fragColor, vec4(vec3(pow(min(d1+.95, d2+.95), 8.0)), 1.0)*logo_c3, (1.0-step(0.0, min(d1, d2)))*logo_c3.a);\r\n\tstrokeAA(min(d1, d2), logo_c2, fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.1, d2+.1), logo_c2 * vec4(0.8), fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.2, d2+.2), logo_c2 * vec4(0.6), fragColor, w, length(fwidth(p)));\r\n\tstrokeAA(min(d1+.3, d2+.3), logo_c2 * vec4(0.4), fragColor, w, length(fwidth(p)));\r\n\t\r\n\tfloat d3 = sdSegment(p, vec2(1.0, 0.0), vec2(-1.0, 0.0));\r\n\tstrokeAA(d3, logo_c2, fragColor, w, length(fwidth(p)));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized pixel coordinates\r\n    vec2 vUV = fragCoord/iResolution.xy;\r\n    \r\n    \r\n    // resolution\r\n    vec2 res = iResolution.xy;\r\n    \r\n    // aspect ratio\r\n    float aspect = res.x / res.y;\r\n\t\r\n\t// -.5 to .5 coordinate space\r\n\tvec2 p = vUV.st-.5;\r\n\t\r\n\tvec2 logo_offset = vec2(0.0, 0.0);\r\n\t\r\n\t// pixel size\r\n\tfloat px_size = 0.0;\r\n\t\r\n\t// alignment for different aspect ratios\r\n\tif (aspect > 1.0)\r\n\t{\r\n\t\tp.x *= aspect;\r\n\t\tlogo_offset.x = (aspect>1.0+logo_s.y*2.0)?.5 : .25;\r\n\t\tpx_size = 1.0/res.y;\r\n\t} else {\r\n\t\tp.y /= aspect;\r\n\t\tlogo_offset.y = (aspect<1.0-logo_s.y*2.0)?.5 : .25;\r\n\t\tpx_size = 1.0/res.x;\r\n\t} \r\n\t\r\n\r\n\t\r\n\t// background color\r\n\tfragColor = bg_c;\r\n\t\r\n\t// square grid\r\n\tgrid(p, px_size, fragColor);\r\n\t\r\n\t// circle grid\r\n\tcircleGrid(p, px_size, fragColor);\r\n\t\r\n\t// big circles\r\n    circle(p, vec2(0), 0.5, circle_c, px_size, fragColor);\r\n    \r\n    // diagonal lines\r\n    diagonals(p, px_size, aspect, fragColor);\r\n    \r\n    // vertical center lines\r\n\tcenterV(p, px_size, fragColor);\r\n\t\r\n\t// horizontal center lines\r\n\tcenterH(p, px_size, fragColor);\r\n\t\r\n\t// rainbow circle\r\n    rainbowCircle(p, vec2(0), .333, vec4(1.0), px_size, fragColor);\r\n\r\n\t// border lines\r\n    //vec2 b_pos = vec2(vUV.x * aspect, vUV.y);\r\n    //b_pos = vUV.xy * res;\r\n    border(vUV.st, res, fragColor);\r\n    \r\n\r\n    // mw logo\r\n\tmwLogo(p, logo_offset, logo_s.y, aspect, px_size, fragColor);\r\n\tmwLogo(p, -logo_offset, logo_s.y, aspect, px_size, fragColor);\r\n\r\n\t\r\n\t//pxGrid(p, px_size, fragColor);\r\n}", "sourceMedias": {}}, {"niceName": "Black", "containers": {"mediaParameters": {"parameters": [{"value": [0.0, 0.0, 0.0, 1.0], "controlAddress": "/color"}]}}, "type": "Solid Color"}, {"parameters": [{"value": "Git/Traces/Image/Mire_Jar.png", "controlAddress": "/filePath"}], "niceName": "Mire Jar", "containers": {"mediaParameters": {}}, "type": "Picture"}, {"niceName": "Sequence", "containers": {"mediaParameters": {}, "sequence": {"parameters": [{"value": 630.0, "controlAddress": "/totalTime"}, {"value": 630.0, "controlAddress": "/viewEndTime"}], "niceName": "Sequence", "type": "Sequence", "layers": {"hideInEditor": true, "items": [{"parameters": [{"value": 60.0, "controlAddress": "/listSize"}, {"value": 60, "hexMode": false, "controlAddress": "/uiHeight"}], "niceName": "Media", "containers": {"blocks": {"hideInEditor": true, "viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Media"}], "viewOffset": [0, 0], "viewZoom": 1.0}, "cues": {"hideInEditor": true, "viewOffset": [0, 0], "viewZoom": 1.0}, "editing": true}}, "type": "Sequence"}], "viewOffset": [0, 0], "viewZoom": 1.0}, "screen": {"items": [{"parameters": [{"value": 3, "hexMode": false, "controlAddress": "/screenNumber"}], "niceName": "Jar", "containers": {"surface": {"items": [{"parameters": [{"value": "/testPatternJarFront", "controlAddress": "/media"}], "niceName": "Devant Scene", "containers": {"positionning": {"parameters": [{"value": [0.01844432577490807, 0.8647338151931763], "controlAddress": "/topLeft"}, {"value": [0.672050952911377, 0.9331172108650208], "controlAddress": "/topRight"}, {"value": [0.02383317053318024, 0.1618572473526001], "controlAddress": "/bottomLeft"}, {"value": [0.6566133499145508, -0.04846876487135887], "controlAddress": "/bottomRight"}], "editorIsCollapsed": true, "containers": {"bezier": {"editorIsCollapsed": true}}}, "adjustments": {"parameters": [{"value": "", "controlAddress": "/mask"}], "editorIsCollapsed": true}, "aspectRatio": {}, "pins": {"viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Surface"}, {"parameters": [{"value": "/testPatternJarBack", "controlAddress": "/media"}], "niceName": "Fond de scene", "containers": {"positionning": {"parameters": [{"value": [0.6716759204864502, 0.9336384534835815], "controlAddress": "/topLeft"}, {"value": [0.9979653358459473, 0.9841839075088501], "controlAddress": "/topRight"}, {"value": [0.6601967215538025, 0.1635164171457291], "controlAddress": "/bottomLeft"}, {"value": [0.9896734952926636, 0.003307802136987448], "controlAddress": "/bottomRight"}], "editorIsCollapsed": true, "containers": {"bezier": {"editorIsCollapsed": true}}}, "adjustments": {"parameters": [{"value": "", "controlAddress": "/mask"}], "editorIsCollapsed": true}, "aspectRatio": {}, "pins": {"viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Surface"}], "viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Screen"}, {"niceName": "Fond De sc\u00e8ne", "containers": {"surface": {"items": [{"parameters": [{"value": "/testPatternFondDeScneJar", "controlAddress": "/media"}], "niceName": "Fond de scene", "editorIsCollapsed": true, "containers": {"positionning": {"parameters": [{"value": [0.1655958890914917, 0.9641090631484985], "controlAddress": "/topLeft"}, {"value": [0.288090318441391, 0.9270801544189453], "controlAddress": "/topRight"}, {"value": [0.1580488234758377, 0.1085290312767029], "controlAddress": "/bottomLeft"}, {"value": [0.2821776866912842, 0.1994165331125259], "controlAddress": "/bottomRight"}], "editorIsCollapsed": true, "containers": {"bezier": {"editorIsCollapsed": true}}}, "adjustments": {"parameters": [{"value": "", "controlAddress": "/mask"}], "editorIsCollapsed": true}, "aspectRatio": {"parameters": [{"value": 1.777777791023254, "controlAddress": "/ratioValue"}]}, "pins": {"viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Surface"}, {"parameters": [{"value": "/testPatternFondDeScne", "controlAddress": "/media"}], "niceName": "Jardin", "editorIsCollapsed": true, "containers": {"positionning": {"parameters": [{"value": [0.288090318441391, 0.8918960094451904], "controlAddress": "/topLeft"}, {"value": [0.8483122587203979, 0.86149001121521], "controlAddress": "/topRight"}, {"value": [0.2821776866912842, 0.1994165331125259], "controlAddress": "/bottomLeft"}, {"value": [0.8304761052131653, 0.1984316259622574], "controlAddress": "/bottomRight"}], "editorIsCollapsed": true, "containers": {"bezier": {"editorIsCollapsed": true}}}, "adjustments": {"parameters": [{"value": "", "controlAddress": "/mask"}], "editorIsCollapsed": true}, "aspectRatio": {"parameters": [{"value": 1.777777791023254, "controlAddress": "/ratioValue"}]}, "pins": {"viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Surface"}, {"parameters": [{"value": "/black", "controlAddress": "/media"}], "niceName": "Surface", "containers": {"positionning": {"parameters": [{"value": [0.162583515048027, 0.6138613820075989], "controlAddress": "/topLeft"}, {"value": [0.2535379528999329, 0.6215254068374634], "controlAddress": "/topRight"}, {"value": [0.151447668671608, 0.09900990128517151], "controlAddress": "/bottomLeft"}, {"value": [0.2788453102111816, 0.1636871844530106], "controlAddress": "/bottomRight"}], "editorIsCollapsed": true, "containers": {"bezier": {"editorIsCollapsed": true}}}, "adjustments": {"parameters": [{"value": "", "controlAddress": "/mask"}], "editorIsCollapsed": true}, "aspectRatio": {}, "pins": {"viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Surface"}], "viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Screen"}, {"parameters": [{"value": 2, "hexMode": false, "controlAddress": "/screenNumber"}], "niceName": "Xiaomi", "containers": {"surface": {"items": [{"parameters": [{"value": "/testPatternCour", "controlAddress": "/media"}], "niceName": "Surface", "containers": {"positionning": {"parameters": [{"value": [0.10260409116745, 0.9768525362014771], "controlAddress": "/topLeft"}, {"value": [1.0, 0.9944446086883545], "controlAddress": "/topRight"}, {"value": [0.275521993637085, 0.0], "controlAddress": "/bottomLeft"}, {"value": [0.7859407663345337, 0.0], "controlAddress": "/bottomRight"}], "editorIsCollapsed": true, "containers": {"bezier": {"editorIsCollapsed": true}}}, "adjustments": {"parameters": [{"value": "", "controlAddress": "/mask"}], "editorIsCollapsed": true}, "aspectRatio": {}, "pins": {"viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Surface"}], "viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Screen"}, {"parameters": [{"value": false, "controlAddress": "/enabled"}, {"value": 3, "hexMode": false, "controlAddress": "/screenNumber"}], "niceName": "Retro Projection", "containers": {"surface": {"items": [{"parameters": [{"value": "/mireFullHDPortrait", "controlAddress": "/media"}], "niceName": "Surface", "containers": {"positionning": {"parameters": [{"value": [0.8956747055053711, 0.8916847109794617], "controlAddress": "/topLeft"}, {"value": [0.8517789840698242, 0.05670728161931038], "controlAddress": "/topRight"}, {"value": [0.1305396258831024, 0.9617073535919189], "controlAddress": "/bottomLeft"}, {"value": [0.1315750330686569, 0.06195191666483879], "controlAddress": "/bottomRight"}], "editorIsCollapsed": true, "containers": {"bezier": {"editorIsCollapsed": true}}}, "adjustments": {"parameters": [{"value": "", "controlAddress": "/mask"}], "editorIsCollapsed": true}, "aspectRatio": {}, "pins": {"viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Surface"}], "viewOffset": [0, 0], "viewZoom": 1.0}}, "type": "Screen"}], "viewOffset": [0, 0], "viewZoom": 1.0, "editingScreen": "jar"}}